---
title: 网络通信常见问题
date: Sun, 20 Mar 2022 17:39:59 GMT
calendar: 壬寅,虎,癸卯,癸酉,二月,十九,星期一
summary: 从浏览器地址栏输入 url 到请求返回发生了什么？[TOC]### 1.DNS域名（Domain Name System）解析，找到IP（Internet Protocol）地址；- DNS解析过程：本地的域名服务器向域名空间不同层次发起查询：根域名服务器查找(.) -> 顶级域名服务器查找(.com) -> 权威域名服务器（google.co ...
description: 从浏览器地址栏输入 url 到请求返回发生了什么？[TOC]### 1.DNS域名（Domain Name System）解析，找到IP（Internet Protocol）地址；- DNS解析过程：本地的域名服务器向域名空间不同层次发起查询：根域名服务器查找(.) -> 顶级域名服务器查找(.com) -> 权威域名服务器（google.co ...
cover: https://gitee.com/hughes-hc/images/raw/master/img/202203121735014.png
author: hughes
primary: e1e4e1
secondary: 1e1b1e
readTime: 34 min read
words: 6646
tag: ['计算机网络', 'HTTP', 'DNS']
---
# 网络通信常见问题

## 从浏览器地址栏输入 url 到请求返回发生了什么？


### 1.DNS域名（Domain Name System）解析，找到IP（Internet Protocol）地址；

- **DNS解析过程**：本地的域名服务器向域名空间不同层次发起**查询**：根域名服务器查找(.) -> 顶级域名服务器查找(.com) -> 权威域名服务器（google.com）

- **DNS缓存**：浏览器缓存，系统缓存，路由器缓存，ISP（Internet Service Provider）服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

- **DNS负载均衡**：同一个主机名配置多个IP地址。CDN(Content Delivery Network)就是利用DNS的重定向技术，返回一个最近的IP地址给用户。

- **dns-prefetch**：是一种 DNS 预解析技术，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间。

参考链接：[字节面试被虐后，是时候搞懂 DNS 了 - 掘金 (juejin.cn)](https://juejin.cn/post/6990344840181940261#heading-3)

### 2.建立TCP连接

- **为什么要三次握手**？

  由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。

  - 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
  - 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
  - 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

- **画出三次握手的示意图**？

  ![](https://gitee.com/hughes-hc/images/raw/master/img/202203121735014.png)

  SYN：(synchronous同步位)，ACK：(acknowledgement 确认位)， ISN：(Initial Sequence Number)，seq：（Sequence序列号位）

  - 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 **`SYN_SEND`** 状态。

    首部的**同步位SYN=1**，**初始序号seq=x**，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

  - 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 **`SYN_RCVD`** 的状态。

    在确认报文段中**SYN=1**，**ACK=1**，**确认号ack=x+1**，**初始序号seq=y**。

  - 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 **`ESTABLISHED`** 状态，此时，双方已建立起了连接。

    确认报文段**ACK=1**，确认号**ack=y+1**，**序号seq=x+1**（初始为seq=x，第二个报文段所以要+1），**ACK报文段可以携带数据**，不携带数据则不消耗序号。

- **什么是半连接队列？**

  服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

  当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

  **SYN-ACK 重传次数**的问题：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

- **ISN(Initial Sequence Number)是固定的吗？**

  ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。**如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。**

- **三次握手过程中可以携带数据吗？**

  **第三次握手是可以携带数据**。假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

- **SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包**，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

- **关闭TCP连接为什么要进行四次挥手？**

  这由TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。**客户端或服务器均可主动发起挥手动作**。**关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文**，告诉客户端，"你发的FIN报文我收到了"。只有**等到我服务端所有的报文都发送完了，我才能发送FIN报文**，因此不能一起发送。　故需要四次挥手。

  - 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

  - 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

  - 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

  - 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

    ![](https://gitee.com/hughes-hc/images/raw/master/img/202203121734424.png)

  收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。**

- **什么是2MSL等待状态？**  **等待2MSL的意义？**

  MSL（Maximum Segment Lifetime）：最长报文段寿命。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

  因为**最后一个ACK报文有可能丢失**，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。**服务器会超时重传这个FIN-ACK**，接着客户端再重传一次确认，**重新启动时间等待计时器**。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

参考连接：       

[面试官，不要再问我三次握手和四次挥手 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903958624878606)

[计算机网络太难？了解这一篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903951335178248)

### 3.发送http 请求

- **谈一谈对URI的理解？**

  ```
  scheme://user:passwd@host:port/path?query#fragment
  ```

  URI只能使用`ASCII`码表示，**所有非`ASCII`码均转为十六进制字节值**然后在前边加个%。

  参考链接：[（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904100035821575#heading-6)

- **常见的HTTP方法有哪些？**

  - **GET**: 通常用来获取资源
  - **POST**: 提交数据，即上传数据
  - **PUT**: 修改数据
  - **Patch**    与PUT方法一样，用于资源更新。区别，1.Patch是对资源部分更新，PUT是整体更新 2. 资源不存在时，Patch会创建新资源，PUT不会
  - **DELETE**: 删除资源(几乎用不到)
  - HEAD: 与GET请求头部一致，只是不包含消息体，常用来检测url的有效性
  - CONNECT: 建立连接隧道，用于代理服务器
  - OPTIONS: 两种场景: 1. 获取资源支持的http方法 2. 跨域预检请求，检测实际请求是否可被浏览器接受
  - TRACE: 回显服务收到的请求，用于测试或诊断。一般禁用，防止被攻击或盗取信息

- **说一下POST和GET的区别？**

  - **语义化**：使用场景上的不同，GET一般用于获取资源，POST用于提交数据；
  - **安全性**：POST相对于更安全；
  - **编码**：GET使用ASCII码编码，POST一般没有限制
  - **幂等**：`GET`是**幂等**的，而`POST`不是。(`幂等`表示执行相同的操作，结果也是相同的)；
  - **可缓存**：get请求会缓存资源，比如获取的一些静态资源二次请求刷新页面请求时间会很短；
  - 长度限制：url长度限制，而POST没有限制；
  - 两个TCP数据包；

- **谈下 HTTP 1.0 和 1.1、1.2 的主要变化？**

  - HTTP1.1开始**支持长连接**，HTTP 可以在一次 TCP 连接中不断发送请求。

  - HTTP1.1 支持只发送 header 而不发送 body，**节约带宽**。请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）。也可只返回头部信息204。新增了

  - HTTP1.1 **的 host 字段**。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。

    

  - **HTTP2.0的新特性**

    - **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
    - **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
    - **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
    - **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

    [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 - _浪潮之巅.☆ - 博客园 (cnblogs.com)](https://www.cnblogs.com/heluan/p/8620312.html)

- **谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？**

  在 HTTP/1.0 中**默认使用短连接**。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。而从 HTTP/1.1 起，**默认使用长连接，用以保持连接特性**。使用长连接的 HTTP 协议，会在响应头加入`Connection:keep-alive`。

- **长轮询、短轮询和webSocket的区别？**

  - 短轮询：就是定时向服务器发送请求，传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。
    - 优点：前后端实现简短。
    - 缺点：浪费资源，浪费带宽，难以维护，响应无序。
  - 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。
    - 优点：在无消息的情况下不会频繁的请求，耗费资源小。
    - 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。
    - 实例：WebQQ、Hi网页版、Facebook IM。
  - Websocket：是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。
    - 优点：优点：请求响应快，不浪费资源。而websocket则允许我们在一条ws连接上同时并发多个请求
    - 缺点：主流浏览器支持的Web Socket版本不一致；服务端没有标准的API。
    - 实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询

- **HTTP 和 HTTPS 的区别？**

  - 开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
  -  资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
  - 端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
  - 安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

- **什么是对称加密和非对称加密？**

  对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

  非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

- **HTTPS的工作原理？**

### 4.服务器处理请求并返回 HTTP 报文

- **常见的HTTP状态码有了解吗？**  

  - **1XX 信息**

    - 100 Continue ：表明**到目前为止都很正常**，**客户端可以继续发送请求或者忽略这个响应**。

  - **2XX 成功**

    - 200 OK

    - 204 No Content ：请求**已经成功处理**，但是返回的**响应报文不包含实体的主体部分**。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
    - 206 Partial Content ：表示**客户端进行了范围请求**，响应报文包含由 Content-Range 指定范围的实体内容。

  - **3XX 重定向**

    - 301 Moved Permanently ：**永久性重定向**；
    - 302 Found ：**临时性重定向**；
    - 303 See Other ：和 302 有着相同的功能，但是 **303 明确要求客户端应该采用 GET 方法获取资源**。

    - 304 Not Modified ：如果请求**报文首部包含一些条件**，例如：**If-Match**，If-Modified-Since，If-None-Match，**If-Range**，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
    - 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 **307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法**。

  - **4XX 客户端错误**

    - 400 Bad Request ：请求报文中存在语法错误。
    - 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
    - 403 Forbidden ：请求被拒绝。
    - 404 Not Found

  - **5XX 服务器错误**

    - 500 Internal Server Error ：服务器正在执行请求时发生错误；
    - 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
- **说一说正向代理和反向代理？**
  - 我们常说的代理也就是指正向代理，正向代理的过程，**它隐藏了真实的请求客户端**，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。
  - 这种代理模式下，**它隐藏了真实的服务端**，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现负载平衡。
- **实现负载均衡的两种方式？**
  - **一种是使用反向代理的方式，用户的请求都发送到反向代理服务上**，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。
  - **另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡**。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。

[「查缺补漏」巩固你的HTTP知识体系 - 掘金 (juejin.cn)](https://juejin.cn/post/6857287743966281736#heading-16)

### 5.浏览器渲染页面

![](https://gitee.com/hughes-hc/images/raw/master/img/202203121735744.png)

### 6.断开 TCP 连接

## 谈下你对五层网络协议体系结构的理解？

来源：OSI（开放式互联网系统：Open System Interconnection）七层体系结构由于缺乏商业驱动力、协议复杂运行效率低、以及层次划分不合理等原因未落地实践。所以中和OSI和TCP/IP的优点，我们采用五层协议体系结构进行学习。

![](https://gitee.com/hughes-hc/images/raw/master/img/202203121735505.png)

### 1.应用层（application layer）

- 说明：应用层协议定义的是**应用进程**（进程：主机中正在运行的程序）**间的通信和交互的规则**。对于不同的网络应用需要不同的应用层协议。我们把**应用层交互的数据单元称为报文**。

- 协议：域名系统 DNS、 HTTP 协、支持电子邮件的 SMTP 协议。

### 2.运输层（transport layer）

- 说明：**主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。传输层具有复用和分用的功能。**复用**：多个应用层进程可同时使用下面运输层的服务；**分用**：是运输层把收到的信息分别交付上面应用层中的相应进程。

- 协议：

  - 提供**面向连接**的，**可靠的**数据传输服务的TCP（Transmisson Control Protocol）协议；
  - 提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）的UDP（User Datagram Protocol）协议。

- **分别对应的应用层协议有哪些**？

  - TCP：HTTP、FTP、SMTP、TELNET
  - UDP：DNS、SNMP（简单网络管理协议）、TFTP(Trival File Transfer Protocal)：简单文件传输协议

    ![](https://gitee.com/hughes-hc/images/raw/master/img/202203121735029.awebp)

- **TCP协议是如何保证可靠性传输的？**

  1. **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；

  2. **对失序数据包重排序**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；

  3. **丢弃重复数据**：对于重复数据，能够丢弃重复数据；

  4. **应答机制**：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

  5. **超时重发**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

  6. **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的**滑动窗口协议**。

### 3.网络层（network layer）

- 说明：在计算机网络中进行通信的两个计算机之间可能会经过很**多个数据链路**，也可能还要经过**很多通信子网**。网络层的任务就是**选择合适的网间路由和交换结点**， 确保数据及时传送。网络层把运输层产生的报文段或用户数据报**封装成分组和包**进行传送。
- 协议：IP协议、ARP协议等

### 4.数据链路层（data link layer）

- 说明：在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，**在两个相邻节点间的链路上传送帧**。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

- 协议：自动重传请求协议ARQ、停止等待协议CSMA/CD、点对点PPP协议

- **谈谈对停止等待协议的理解？**

  停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

- **自动重传请求 ARQ 协议**

  停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

### 5.物理层（physical layer）

- 说明：在物理层上所**传送的数据单位是比特**。物理层的**作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**。
- 协议：中继器、集线器、网线、HUB

<img src="https://gitee.com/hughes-hc/images/raw/master/img/202203121736940.png" alt="image-20220221210950738" style="zoom: 80%;" />

参考链接：

[计算机网络太难？了解这一篇就够了 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903951335178248)